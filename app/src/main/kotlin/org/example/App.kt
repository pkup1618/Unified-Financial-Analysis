/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example

import com.itextpdf.text.pdf.PdfReader
import com.itextpdf.text.pdf.parser.*
import com.itextpdf.text.pdf.parser.Vector
import java.math.BigDecimal
import java.text.SimpleDateFormat
import java.time.LocalDate
import java.util.*




fun main(args: Array<String>) {
    parseSberDoc()
}

fun printSberDoc() {
    val reader = PdfReader("docs/sber-pdf.pdf")

    for (i in 1..reader.numberOfPages) {
        val strategy = TextExtractionStrategyImpl()

        // вызываем, чтобы наша реализация стратегия получила информацию о тексте на странице
        PdfTextExtractor.getTextFromPage(reader, i, strategy)
        println("Page : $i")

        for (entry in strategy.getStringsWithCoordinates()) {
            println("----------------")
            println("(x: ${entry.key.x}, y: ${entry.key.y})")
            println(entry.value)
        }
    }

    reader.close()
}

fun parseSberDoc() {
    val reader = PdfReader("docs/sber-pdf.pdf")

    for (i in 1..reader.numberOfPages) {
//        println("Page : $i")

        val strategy = TextExtractionStrategyImpl()
        PdfTextExtractor.getTextFromPage(reader, i, strategy)

        val entries = strategy.getStringsWithCoordinates()
        val usefulEntriesHeights = entries
            .filterValues { it.matches(Regex("^\\d{6}\$")) }
            .map { it.key.y }

        val usefulEntries = entries
            .filterKeys { it.x < 530 }
            .filterKeys { it.y in usefulEntriesHeights }
        val groupedStrings = usefulEntries.entries.groupBy { it.key.y }

        val operations = groupedStrings.map { height ->
            val objectAsArray = height.value.map { it.value }

            val trim1 = objectAsArray[4]
                .replace("\\u00A0".toRegex(), "")

            val trim2 = trim1
                .replace(",".toRegex(), ".")

            Operation(
                SimpleDateFormat("dd.MM.yyyy HH:mm").parse("${objectAsArray[0]} ${objectAsArray[1]}"),
                trim2.toBigDecimal(),
                objectAsArray[3],
                null,
            )
        }

        operations.forEach {
            println(it)
        }


    }

    reader.close()
}


class TextExtractionStrategyImpl : TextExtractionStrategy {
    private val textMap = mutableMapOf<Float, MutableMap<Float, String>>()

    override fun getResultantText(): String {
        val stringBuilder = StringBuilder()

        val sortedTextWithCoords = textMap
            .mapValues { it.value.toSortedMap() }
            .toSortedMap()

        sortedTextWithCoords.forEach { x ->
            x.value.forEach { y ->
                stringBuilder.append(y.value)
            }
        }

        return stringBuilder.toString()
    }

    override fun renderText(renderInfo: TextRenderInfo) {
        // вытаскиваем координаты
        val x = renderInfo.baseline.startPoint[Vector.I2]
        val y = renderInfo.baseline.startPoint[Vector.I1]

        // если до этого мы не добавляли элементы из этой строчки файла.
        if (!textMap.containsKey(y)) {
            textMap[y] = TreeMap()
        }

        textMap[y]?.set(x, renderInfo.text)
    }

    /**
     * Отсортированные текстовые записи по координатной сетке (сначала по x, потом по y)
     */
    fun getStringsWithCoordinates(): SortedMap<Coords2D, String> {
        val result = mutableMapOf<Coords2D, String>()

        textMap.forEach { x ->
            x.value.forEach { y ->
                result[Coords2D(x.key, y.key)] = y.value
            }
        }

        return result.toSortedMap()
    }

    override fun beginTextBlock() {}

    override fun renderImage(imageRenderInfo: ImageRenderInfo?) {}

    override fun endTextBlock() {}
}
